package com.ea.throttle.mock;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Random;

public class CSVMDGenerator {

	static Random r = new Random();

	static final String START_DATE_STR = "2012-06-25 00:00:00";
	static Date START_DATE;

	static final int PROB_FOR_BAD = 5;

	public static final String TABLE_NAME = "log_table";

	static final int USER_LIST_SIZE = 20;
	static final int FIN_INST_LIST_SIZE = USER_LIST_SIZE;
	static final int GROUP_COUNT_WITH_MULTI_USERS = USER_LIST_SIZE / 5; // get 200 groups and
															// put multi-users
															// in them, must be
															// smaller
															// the user list
															// size

	static final int INSERTION_THRESHOLD = (USER_LIST_SIZE/2) * (USER_LIST_SIZE/2);  // TODO For debugging purposes, should be -1 in the end

	static final int BATCH_SIZE = 50000;

	static final int STEP_INTERVAL = 400;

	static List<User> users = null;

	static List<UserGroup> user_groups = null;

	static List<FinInst> fin_insts = null;

	static String[] dbArgs = {"com.mysql.jdbc.Driver",
		"jdbc:mysql://127.0.0.1:3306/test","","","log_table"};

	// all the products are generated by the Product class

	static {
		DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		try {
			START_DATE = df.parse(START_DATE_STR);
		} catch (ParseException e) {
			e.printStackTrace();
		} // won't happen
		users = new ArrayList<User>(USER_LIST_SIZE);
		fin_insts = new ArrayList<FinInst>(FIN_INST_LIST_SIZE);
		user_groups = new ArrayList<UserGroup>(USER_LIST_SIZE);
	}

	static void generateLists() {

		for (int i = 0; i < USER_LIST_SIZE; i++) {
			users.add(new User(i + 1, PROB_FOR_BAD));
		}

		ArrayList<User> tmpUsers = new ArrayList<User>(users);

		for (int i = 0; i < GROUP_COUNT_WITH_MULTI_USERS; i++) {
			UserGroup g = new UserGroup();
			int j = 0;
			do {
				int rdn = r.nextInt(tmpUsers.size());
				User tmpu = tmpUsers.remove(rdn);
				g.users.add(tmpu);
				tmpu.group = g;
			} while (++j <= r.nextInt(4)); // TODO to change this group size
											// random to a constant
			user_groups.add(g);
		}

		// add the rest of the users into the group with only one user
		for (User u : tmpUsers) {
			UserGroup g = new UserGroup();
			g.users.add(u);
			user_groups.add(g);
		}

		System.out.printf("Group size generated:%d\nGoing to insert %d items.\n",
				user_groups.size(), INSERTION_THRESHOLD);

		// shuffle the user groups generated
		Collections.shuffle(user_groups);

		// specify the financial instruments to the user groups
		// remember, one group may have only one financial instruments, or may
		// have more than one

		for (int i = 0, j = 0; i < user_groups.size(); i++) {
			UserGroup g = user_groups.get(i);
			int k = 0;
			do {
				FinInst f = new FinInst(String.format("FI20-%d", ++j));
				g.finInsts.add(f);
				fin_insts.add(f);
			} while (++k <= r.nextInt(4)); // TODO change this instrument size
											// to constant

			// there are rare occasions where user groups shares the financial
			// instruments
			k = 0;
			UserGroup controlGroup = null;
			if (r.nextInt(400) == 45) // this might only happen for a 1/400
										// probability
			{
				controlGroup = user_groups.get(r.nextInt(i));
				g.finInsts.add(controlGroup.finInsts.get(r
						.nextInt(controlGroup.finInsts.size())));
				if (r.nextInt(50) == 45) {
					UserGroup tmpGroup = null;
					while (controlGroup == (tmpGroup = user_groups.get(r
							.nextInt(i)))) {

					}
					;
					g.finInsts.add(tmpGroup.finInsts.get(r
							.nextInt(tmpGroup.finInsts.size())));
				}
			}
		}
		System.out.printf("The fin insts generated for groups:%d\n",
				fin_insts.size());
	}

	// now we can use these guys to generate transactions
	static void generateTransactions(String fileName) throws Exception{

		VTMockCSVWriter mockBatch = new VTMockCSVWriter(fileName);

		long endTimeStamp = new Date().getTime();
		long beginTimeStamp = START_DATE.getTime();
		long stepInterval = STEP_INTERVAL;
		long count = 0;

		System.out.printf("About to insert %d records. Each with time interval increments:%dms\n", INSERTION_THRESHOLD, stepInterval);
		Random rdmT = new Random();
		Random rdmU = new Random();
		try{
		mockBatch.begin();
		for (long i = beginTimeStamp, j = 0; i < endTimeStamp; i += stepInterval) { // j is used as log id
			double gaus = rdmT.nextGaussian();
			int index = (int) ((Math.abs(gaus) / 10) * user_groups.size());
			UserGroup g = user_groups.get(index);
			assert (g.users.size() != 0);
			User u = g.users.get(rdmU.nextInt(g.users.size()));
			FinInst f = g.finInsts.get(rdmU.nextInt(g.finInsts.size()));
			Transaction t = new Transaction();
			t.timestamp = i;
			t.finInst = f;
			t.user = u;
			t.product = Product.getRandomProduct();
			t.invoiceAmount = rdmU.nextDouble() * 50;
			t.logId = String.valueOf(++j);
			t.ip = IP.getRandomIP();
			Suspect s = u.suspect;
			double transFactor = 0.1;
			switch (s) { // TODO decouple the good/bad with string
			case good:
				t.suspect = "good";
				break;
			case bad:
				t.suspect = "bad";
				transFactor = 0.8;
				break;
			case between:
				if (rdmU.nextBoolean())
				{
					t.suspect = "good";
					transFactor = 0.1;
				}
				else
				{
					t.suspect = "bad";
					transFactor = 0.8; // TODO each user will have a transaction factor. Bad user will
									// have higher
				}
			default:
			}
			gaus = rdmT.nextGaussian();
			if(gaus < transFactor)  // the probability for good and bad users are different
			{
				mockBatch.add2Batch(t);
				if(++count >= INSERTION_THRESHOLD)
					break;
			}
		}
		}catch(Exception e){
			e.printStackTrace();
		}finally{
			try{mockBatch.close();}catch(Exception e1){}
		}
	}

	public static void main(String[] args) throws Exception {
		generateLists();
		generateTransactions("mock_csv_small.csv");
	}
}

// The idea is:
/**
 * There will be 50 bad user groups and 500 good users
 *
 */
